### Description

Given an integer arrayÂ `nums`Â ofÂ **unique**Â elements, returnÂ _all possible_Â 

_subsets_

Â _(the power set)_.

The solution setÂ **must not**Â contain duplicate subsets. Return the solution inÂ **any order**.

**Example 1:**

**Input:** nums = \[1,2,3]
**Output:** \[\[],\[1],\[2],\[1,2],\[3],\[1,3],\[2,3],\[1,2,3]]

**Example 2:**

**Input:** nums = \[0]
**Output:** \[\[],\[0]]

**Constraints:**

- `1 <= nums.length <= 10`
- `-10 <= nums[i] <= 10`
- All the numbers ofÂ `nums`Â areÂ **unique**.

**My Implementation**

```cpp
//Approach-1
//T.C : O(2^n)
//S.C :  O(2^n*length of each subset) to store each subset
//       The recursion stack space complexity is O(N) , the maximum depth of the recursion is N, where N is the length of the input array.
class Solution {
public:
    vector<vector<int>> result;

    void solve(vector<int>& nums, int idx, vector<int>& temp) {
        if(idx >= nums.size()) {
            result.push_back(temp);
            return;
        }

        temp.push_back(nums[idx]);
        solve(nums, idx+1, temp);
        temp.pop_back();
        solve(nums, idx+1, temp);
    }

    vector<vector<int>> subsets(vector<int>& nums) {
        vector<int> temp;

        solve(nums, 0, temp);

        return result;
    }
};
```

# ğŸ¯Problem Explaination:

Given a set of distinct integers,Â `nums`, return all possible subsets (the power set).  
**Explanation:**  
The problem asks to generate all possible subsets (the power set) of the given set of distinct integers. The subsets can contain any combination of integers from the input set, including the empty subset and the set itself.

For example, for the input setÂ `[1, 2, 3]`, the output contains all possible subsets:

- `[1]`,Â `[2]`,Â `[3]`Â (single-element subsets)
- `[1, 2]`,Â `[1, 3]`,Â `[2, 3]`Â (two-element subsets)
- `[1, 2, 3]`Â (three-element subset)
- `[]`Â (empty subset)

### ğŸ“¥Input:

- A list of distinct integers,Â `nums`.

### ğŸ“¤Output:

- A list of lists containing all possible subsets of the input setÂ `nums`, including the empty subset.

# ğŸ” Methods To Solve This Problem:

I'll be covering three different methods to solve this problem:

1. Backtracking (Recursive Approach)
2. Bit Manipulation
3. Iterative Approach (Generating All Subsets)

# 1ï¸âƒ£Backtracking (Recursive Approach):

- Use a recursive function to generate all subsets.
- At each step, decide whether to include the current element in the subset or not.
- Recur for the remaining elements after including and excluding the current element.
- Base case: When there are no more elements left, add the subset to the result.
- This approach builds subsets incrementally, including one element at a time.

# CodeğŸ‘¨ğŸ»â€ğŸ’»:

```cpp
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>> result;
        vector<int> path;
        backtrack(nums, 0, path, result);
        return result;
    }
    
    void backtrack(vector<int>& nums, int start, vector<int>& path, vector<vector<int>>& result) {
        result.push_back(path);
        for (int i = start; i < nums.size(); i++) {
            path.push_back(nums[i]);
            backtrack(nums, i + 1, path, result);
            path.pop_back();
        }
    }
};
```

# Let's walkthroughğŸš¶ğŸ»â€â™‚ï¸ the implementation process with an example for better understandingğŸ¯:

## ğŸ“¥Input:Â `nums = [1, 2, 3]`.

### ğŸ“šStep-by-Step Walkthrough:

1. Initially, theÂ `result`Â list is empty.
2. We start with the initial call to theÂ `backtrack`Â function withÂ `start = 0`Â andÂ `path = []`.
3. Inside theÂ `backtrack`Â function:
    - We add the currentÂ `path`Â (empty list) to theÂ `result`. So,Â `result = [[]]`.
    - We iterate over the elements ofÂ `nums`Â starting from indexÂ `start = 0`.
4. For the first elementÂ `1`:
    - We addÂ `1`Â to theÂ `path`, soÂ `path = [1]`.
    - We make a recursive call toÂ `backtrack(1, [1])`.
5. Inside the recursive call withÂ `start = 1`Â andÂ `path = [1]`:
    - We add the currentÂ `path`Â `[1]`Â to theÂ `result`. So,Â `result = [[], [1]]`.
    - We iterate over the elements ofÂ `nums`Â starting from indexÂ `start = 1`.
6. For the second elementÂ `2`:
    - We addÂ `2`Â to theÂ `path`, soÂ `path = [1, 2]`.
    - We make a recursive call toÂ `backtrack(2, [1, 2])`.
7. Inside the recursive call withÂ `start = 2`Â andÂ `path = [1, 2]`:
    - We add the currentÂ `path`Â `[1, 2]`Â to theÂ `result`. So,Â `result = [[], [1], [1, 2]]`.
    - We iterate over the elements ofÂ `nums`Â starting from indexÂ `start = 2`.
8. For the third elementÂ `3`:
    - We addÂ `3`Â to theÂ `path`, soÂ `path = [1, 2, 3]`.
    - We make a recursive call toÂ `backtrack(3, [1, 2, 3])`.
9. Inside the recursive call withÂ `start = 3`Â andÂ `path = [1, 2, 3]`:
    - We add the currentÂ `path`Â `[1, 2, 3]`Â to theÂ `result`. So,Â `result = [[], [1], [1, 2], [1, 2, 3]]`.
    - SinceÂ `start = 3`Â equals the length ofÂ `nums`, we return from this recursive call.
10. After returning from the recursive call withÂ `start = 2`, we remove the last element fromÂ `path`, soÂ `path = [1, 2]`.
11. We move to the next iteration forÂ `nums[2]`Â (which isÂ `3`).
12. We repeat the same steps forÂ `nums[2] = 3`, and after the recursive call returns, we remove the last element fromÂ `path`Â again.
13. We return from the initial call toÂ `backtrack`Â withÂ `start = 1`, soÂ `path = [1]`.
14. We move to the next iteration forÂ `nums[1]`Â (which isÂ `2`).
15. We repeat the same steps, and after the recursive call returns, we remove the last element fromÂ `path`.
16. We return from the initial call toÂ `backtrack`Â withÂ `start = 0`, soÂ `path = []`.
17. We have iterated through all elements ofÂ `nums`, and the process is complete.

At the end,Â `result`Â contains all the subsets ofÂ `[1, 2, 3]`, including the empty subset, which isÂ `[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]`.

# 2ï¸âƒ£Bit ManipulationğŸ˜:

- Use bit manipulation to generate all possible combinations.
- For a set with n elements, there are 2^n possible subsets.
- Iterate from 0 to 2^n - 1 and for each integer, consider the set bits as indices of elements to include in the subset.
- This approach is efficient in terms of time complexity, as it avoids recursion and extra space.

# CodeğŸ‘©ğŸ»â€ğŸ’»:

```cpp
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>> result;
        int n = nums.size();
        for (int i = 0; i < (1 << n); i++) {
            vector<int> subset;
            for (int j = 0; j < n; j++) {
                if ((i & (1 << j)) > 0) {
                    subset.push_back(nums[j]);
                }
            }
            result.push_back(subset);
        }
        return result;
    }
};
```

# Let's walkthroughğŸš¶ğŸ»â€â™‚ï¸ the implementation process with an example for better understandingğŸ¯:

## ğŸ“¥Input:Â `nums = [1, 2, 3]`.

### ğŸ“šStep-by-Step Walkthrough:

1. Initially, theÂ `result`Â list is empty.
2. We iterate over all possible subsets using bit manipulation. Since there are 3 elements inÂ `nums`, there will beÂ `2^3 = 8`Â subsets.
3. We start the iteration fromÂ `i = 0`Â toÂ `i = 7`, inclusive.
4. For each value ofÂ `i`, we check the binary representation ofÂ `i`Â to determine which elements to include in the subset.
5. ForÂ `i = 0`, binary representation isÂ `000`. It means the empty subset, so we addÂ `[]`Â to theÂ `result`.
6. ForÂ `i = 1`, binary representation isÂ `001`. It means including only the third element (`nums[2] = 3`) in the subset. So, we addÂ `[3]`Â to theÂ `result`.
7. ForÂ `i = 2`, binary representation isÂ `010`. It means including only the second element (`nums[1] = 2`) in the subset. So, we addÂ `[2]`Â to theÂ `result`.
8. ForÂ `i = 3`, binary representation isÂ `011`. It means including the second and third elements (`nums[1] = 2`Â andÂ `nums[2] = 3`) in the subset. So, we addÂ `[2, 3]`Â to theÂ `result`.
9. ForÂ `i = 4`, binary representation isÂ `100`. It means including only the first element (`nums[0] = 1`) in the subset. So, we addÂ `[1]`Â to theÂ `result`.
10. ForÂ `i = 5`, binary representation isÂ `101`. It means including the first and third elements (`nums[0] = 1`Â andÂ `nums[2] = 3`) in the subset. So, we addÂ `[1, 3]`Â to theÂ `result`.
11. ForÂ `i = 6`, binary representation isÂ `110`. It means including the first and second elements (`nums[0] = 1`Â andÂ `nums[1] = 2`) in the subset. So, we addÂ `[1, 2]`Â to theÂ `result`.
12. ForÂ `i = 7`, binary representation isÂ `111`. It means including all elements (`nums[0] = 1`,Â `nums[1] = 2`, andÂ `nums[2] = 3`) in the subset. So, we addÂ `[1, 2, 3]`Â to theÂ `result`.
13. After iterating through all possible subsets, theÂ `result`Â contains all subsets ofÂ `[1, 2, 3]`, including the empty subset, which isÂ `[[], [3], [2], [2, 3], [1], [1, 3], [1, 2], [1, 2, 3]]`.

# 3ï¸âƒ£Iterative Approach (Generating All Subsets)ğŸ˜:

- Start with an empty subset and gradually build it.
- Iterate through each element in the given set.
- For each element, clone the existing subsets, add the current element to each cloned subset, and then add these subsets to the result.
- This approach iterates through the set only once and builds subsets incrementally.

# CodeğŸ‘©ğŸ»â€ğŸ’»:
```cpp
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>> result = {{}}; // Add the empty subset
        for (int num : nums) {
            int size = result.size();
            for (int i = 0; i < size; i++) {
                vector<int> subset = result[i];
                subset.push_back(num);
                result.push_back(subset);
            }
        }
        return result;
    }
};
```

# Let's walkthroughğŸš¶ğŸ»â€â™‚ï¸ the implementation process with an example for better understandingğŸ¯:

## ğŸ“¥Input:Â `nums = [1, 2, 3]`.

### ğŸ“šStep-by-Step Walkthrough:

1. Initially, theÂ `result`Â list contains only the empty subset,Â `[]`.
2. We iterate over each element inÂ `nums`.
3. For the first elementÂ `1`:
    - We clone the existing subsets inÂ `result`, which is currentlyÂ `[]`.
    - We addÂ `1`Â to each cloned subset and add them back toÂ `result`. So,Â `result = [[], [1]]`.
4. For the second elementÂ `2`:
    - We clone the existing subsets inÂ `result`, which areÂ `[[], [1]]`.
    - We addÂ `2`Â to each cloned subset and add them back toÂ `result`. So,Â `result = [[], [1], [2], [1, 2]]`.
5. For the third elementÂ `3`:
    - We clone the existing subsets inÂ `result`, which areÂ `[[], [1], [2], [1, 2]]`.
    - We addÂ `3`Â to each cloned subset and add them back toÂ `result`. So,Â `result = [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]`.
6. After iterating through all elements inÂ `nums`, theÂ `result`Â contains all subsets ofÂ `[1, 2, 3]`, including the empty subset.

