### Description

You are given two stringsÂ `start`Â andÂ `target`, both of lengthÂ `n`. Each string consistsÂ **only**Â of the charactersÂ `'L'`,Â `'R'`, andÂ `'_'`Â where:

- The charactersÂ `'L'`Â andÂ `'R'`Â represent pieces, where a pieceÂ `'L'`Â can move to theÂ **left**Â only if there is aÂ **blank**Â space directly to its left, and a pieceÂ `'R'`Â can move to theÂ **right**Â only if there is aÂ **blank**Â space directly to its right.
- The characterÂ `'_'`Â represents a blank space that can be occupied byÂ **any**Â of theÂ `'L'`Â orÂ `'R'`Â pieces.

ReturnÂ `true`Â _if it is possible to obtain the string_Â `target`Â _by moving the pieces of the string_Â `start`Â _**any**Â number of times_. Otherwise, returnÂ `false`.

**Example 1:**

```cpp
Input: start = "_L__R__R_", target = "L______RR"
Output: true
```
**Explanation:** We can obtain the string target from start by doing the following moves:
- Move the first piece one step to the left, start becomes equal to "**L**___R__R_".
- Move the last piece one step to the right, start becomes equal to "L___R___**R**".
- Move the second piece three steps to the right, start becomes equal to "L______**R**R".
Since it is possible to get the string target from start, we return true.

**Example 2:**

```cpp
Input: start = "R_L_", target = "__LR"
Output: false
```
**Explanation:** The 'R' piece in the string start can move one step to the right to obtain "_**R**L_".
After that, no pieces can move anymore, so it is impossible to obtain the string target from start.

**Example 3:**

```cpp
Input: start = "_R", target = "R_"
Output: false
```
**Explanation:** The piece in the string start can move only to the right, so it is impossible to obtain the string target from start.

**Constraints:**

- `n == start.length == target.length`
- `1 <= n <= 10^5`
- `start`Â andÂ `target`Â consist of the charactersÂ `'L'`,Â `'R'`, andÂ `'_'`.

**My Implementation**

```cpp
//Approach-1 (Brute Force to check all possibilities)
//T.C : Exponential in the worst case due to exploring all possible swaps, though memoization reduces redundant computations.
//S.C : Memoization map to store all possible states. ~ O(n^2) states possible
class Solution {
public:
    int n;
    bool solve(string &start, string &target, unordered_map<string, bool>& mp) {
        if(start == target) {
            return true;
        }

        //Memoization
        if(mp.count(start)) {
            return mp[start];
        }

        for(int i = 0; i < start.length(); i++) {
            if(start[i] == 'L' && i > 0 && start[i-1] == '_') {
                swap(start[i], start[i-1]);
                if(solve(start, target, mp) == true) {
                    return true;
                }
                swap(start[i], start[i-1]);
            } else if(start[i] == 'R' && i < n-1 && start[i+1] == '_') {
                swap(start[i], start[i+1]);
                if(solve(start, target, mp) == true) {
                    return true;
                }
                swap(start[i], start[i+1]);
            }
        }

        return mp[start] = false;
    }

    bool canChange(string start, string target) {
        n = start.length();
        unordered_map<string, bool> mp;
        return solve(start, target, mp);
    }
};

//Approach-2 (Optimal using 2 pointers)
//T.C : O(n)
//S.C : O(1)
class Solution {
public:
    bool canChange(string start, string target) {
        int n = start.length();
        int i = 0;
        int j = 0;

        while(i < n || j < n) {
            while(i < n && start[i] == '_') {
                i++;
            }

            while(j < n && target[j] == '_') {
                j++;
            }

            if(i == n || j == n) {
                return i == n && j == n;
            }

            if(start[i] != target[j]) {
                return false;
            }

            if(start[i] == 'L' && i < j) {
                return false;
            }

            if(start[i] == 'R' && i > j) {
                return false;
            }

            i++;
            j++;
            
        }

        return true;
    }
};
```

## Solution

---

### Overview

We are given two strings,Â `start`Â andÂ `target`, both of the same lengthÂ n. These strings consist only of the charactersÂ `'L'`,Â `'R'`, andÂ `'_'`.

Let's look at an example with aÂ `start`Â string ofÂ `"R_L"`Â and aÂ `target`Â string ofÂ `"L_R"`. To achieve this transformation,Â `'L'`Â would need to move leftward andÂ `'R'`Â would need to move rightward, but neither can "jump over" the other due to the step-by-step movement rules that only allow moves into adjacent blank spaces. This restriction inherently prevents characters from crossing each other, making the transformation impossible. Therefore, we returnÂ `false`.

---

### Approach 1: Brute Force (Memory Limit Exceeded)

#### Intuition

A natural first thought to solve this problem is to explore all possible ways to move the pieces. We generate all possible states of theÂ `start`Â string by making valid moves and checking if any of these states match theÂ `target`Â string.

To implement this logic, we start by initializing a queue to store the current states (`stateQueue`) of theÂ `start`Â string. To avoid repetitive lookups for the same state, we use a set to keep track of visited states (`visitedStates`).

Once we have theÂ `visitedStates`Â andÂ `stateQueue`Â ready, we begin by pushing the initialÂ `start`Â string into the queue. For each state, we check if it matches theÂ `target`Â string. If it does, we returnÂ `true`Â because we have found a valid transformation sequence. If the current state does not match theÂ `target`, we generate new states by movingÂ `'L'`Â to the left andÂ `'R'`Â to the right, ensuring that each move is valid according to the rules. We then push each new valid state into the queue and mark it as visited. If the queue is exhausted and we haven't found a matching state, we returnÂ `false`Â because no valid transformation sequence exists.

Due to the worst-case scenario where all possible states (which can be up toÂ n^2Â unique states) need to be stored in the visited states set, this solution results in a memory limit exceeded error.

Explanation of the Total Number of Unique States (Click Here)

#### Algorithm

- Initialize an unordered setÂ `visitedStates`Â to track states that have already been visited and avoid cycles.
    
- Initialize a queueÂ `stateQueue`Â and push theÂ `start`Â state into the queue.
    
- WhileÂ `stateQueue`Â is not empty:
    
    - Extract the front of the queue intoÂ `currentState`.
        
    - IfÂ `currentState`Â matchesÂ `target`, returnÂ `true`.
        
    - For each position inÂ `currentState`Â from indexÂ `1`Â to the end:
        
        - IfÂ `currentState[position]`Â isÂ `'L'`Â and the position to its left isÂ `'_'`:
            - SwapÂ `'L'`Â withÂ `'_'`Â to simulate movingÂ `'L'`Â left.
            - If the new state has not been visited:
                - Push the new state into the queue.
                - Mark the state as visited by inserting it intoÂ `visitedStates`.
            - RestoreÂ `currentState`Â to its original form by swapping back.
        - IfÂ `currentState[position - 1]`Â isÂ `'R'`Â and the position to its right isÂ `'_'`:
            - SwapÂ `'R'`Â withÂ `'_'`Â to simulate movingÂ `'R'`Â right.
            - If the new state has not been visited:
                - Push the new state into the queue.
                - Mark the state as visited by inserting it intoÂ `visitedStates`.
            - RestoreÂ `currentState`Â to its original form by swapping back.
- If the process completes without finding a valid transformation sequence, returnÂ `false`.
    

#### Implementation

```cpp
class Solution {
public:
    bool canChange(string start, string target) {
        // To keep track of visited states to avoid cycles
        unordered_set<string> visitedStates;
        // Queue for current state
        queue<string> stateQueue;
        // Start with the initial state
        stateQueue.push(start);

        while (!stateQueue.empty()) {
            string currentState = stateQueue.front();
            stateQueue.pop();

            // If we reach the target state, return true
            if (currentState == target) return true;

            for (int position = 1; position < currentState.size(); position++) {
                // Try moving 'L' to the left
                if (currentState[position] == 'L' &&
                    currentState[position - 1] == '_') {
                    swap(currentState[position], currentState[position - 1]);
                    if (visitedStates.find(currentState) ==
                        visitedStates.end()) {
                        // Add the new state to the queue
                        stateQueue.push(currentState);
                        // Mark the new state as visited
                        visitedStates.insert(currentState);
                    }
                    // Restore the state
                    swap(currentState[position], currentState[position - 1]);
                }
                // Try moving 'R' to the right
                if (currentState[position - 1] == 'R' &&
                    currentState[position] == '_') {
                    swap(currentState[position], currentState[position - 1]);
                    if (visitedStates.find(currentState) ==
                        visitedStates.end()) {
                        // Add the new state to the queue
                        stateQueue.push(currentState);
                        // Mark the new state as visited
                        visitedStates.insert(currentState);
                    }
                    // Restore the state
                    swap(currentState[position], currentState[position - 1]);
                }
            }
        }

        // If no valid transformation sequence is found, return false
        return false;
    }
};
```

#### Complexity Analysis

LetÂ nÂ be the size of theÂ `start`Â andÂ `target`Â strings.

- Time complexity:Â O(n^2)
    
    The algorithm explores all possible states. In the worst case, each character in the string can be swapped with its adjacent character, leading toÂ nÂ possible swaps per state. Since each state can generate up toÂ nÂ new states, and the algorithm explores all possible states, the time complexity isÂ O(n^2).
    
- Space complexity:Â O(n^2)
    
    The space complexity is dominated by the space required to store the states in theÂ `visitedStates`Â set and theÂ `stateQueue`. In the worst case, all possible states (which can be up toÂ n^2Â unique states) need to be stored in theÂ `visitedStates`Â set. TheÂ `stateQueue`Â can also grow to store up toÂ nÂ states at any given time during the traversal.
    
    Therefore, the space complexity isÂ O(n^2).
    

---

### Approach 2: Using Queue

#### Intuition

Instead of generating all possible moves, we can focus on the fundamental rules that govern whether a transformation is possible. TheÂ `'L'`Â pieces can only move left, and theÂ `'R'`Â pieces can only move right. This means that for any valid transformation:

1. The relative order ofÂ `'L'`s andÂ `'R'`s must remain unchanged since they cannot pass through each other.
2. AnÂ `'L'`Â in theÂ `start`Â string must be at the same position or to the right of its target position.
3. AnÂ `'R'`Â in theÂ `start`Â string must be at the same position or to the left of its target position.

This observation allows us to drastically simplify our approach. Rather than trying different combinations of moves, we can simply extract the positions of allÂ `'L'`Â andÂ `'R'`Â pieces from both strings and compare them in order. By storing these positions in queues (one for theÂ `start`Â string and one for theÂ `target`Â string), we maintain the relative ordering of pieces while ignoring the underscores.

The actual implementation becomes a matter of comparing corresponding pieces from both queues. For each pair of pieces:

1. First, verify they are the same type (bothÂ `'L'`Â or bothÂ `'R'`).
2. Then, depending on the piece type, check if their positions satisfy our movement constraints:
    - `'L'`Â pieces in theÂ `start`Â must not be to the left of their target positions.
    - `'R'`Â pieces must not be to the right of their target positions.

To implement this concept, start by creating two queues to store character-position pairs. Next, populate these queues by iterating through both theÂ `start`Â andÂ `target`Â strings, recording only the non-underscore characters along with their positions. Once the queues are populated, compare their sizes to ensure they match, as this confirms that both strings contain the same number of pieces. Then, process both queues simultaneously, comparing each pair of front characters to verify that they are of the same type (bothÂ `'L'`Â or bothÂ `'R'`) and that their positions allow for valid moves according to the rules. Specifically, forÂ `'L'`Â pieces, ensure that the start position is not to the left of the target position, and forÂ `'R'`Â pieces, ensure that the start position is not to the right of the target position.

This way we transform what would be a quadratic-complexity problem of move generation into a linear-time solution that simply validates position constraints.

#### Algorithm

- Initialize two queues,Â `startQueue`Â andÂ `targetQueue`, to store the non-underscore characters and their indices fromÂ `start`Â andÂ `target`.
    
- Traverse theÂ `start`Â andÂ `target`Â strings:
    
    - If a character inÂ `start`Â is not an underscore (`'_'`), add it along with its index toÂ `startQueue`.
    - If a character inÂ `target`Â is not an underscore, add it along with its index toÂ `targetQueue`.
- Check if the sizes ofÂ `startQueue`Â andÂ `targetQueue`Â are different:
    
    - If they are, returnÂ `false`Â because the number of movable pieces must match.
- WhileÂ `startQueue`Â is not empty:
    
    - Dequeue the front element from bothÂ `startQueue`Â andÂ `targetQueue`.
    - Compare the character and movement rules:
        - If the characters don't match, returnÂ `false`.
        - If the character isÂ `'L'`Â (must only move left), check if its index inÂ `start`Â is less than its index inÂ `target`. If so, returnÂ `false`.
        - If the character isÂ `'R'`Â (must only move right), check if its index inÂ `start`Â is greater than its index inÂ `target`. If so, returnÂ `false`.
- ReturnÂ `true`Â if all characters and their movement rules are valid, indicating thatÂ `start`Â can be transformed intoÂ `target`.
    

#### Implementation

```cpp
class Solution {
public:
    bool canChange(string start, string target) {
        // Queue to store characters and indices from both strings
        queue<pair<char, int>> startQueue, targetQueue;

        // Record non-underscore characters and their indices
        for (int i = 0; i < start.size(); i++) {
            if (start[i] != '_') {
                startQueue.push({start[i], i});
            }
            if (target[i] != '_') {
                targetQueue.push({target[i], i});
            }
        }

        // If number of pieces don't match, return false
        if (startQueue.size() != targetQueue.size()) return false;

        // Compare each piece's type and position
        while (!startQueue.empty()) {
            auto [startChar, startIndex] = startQueue.front();
            startQueue.pop();
            auto [targetChar, targetIndex] = targetQueue.front();
            targetQueue.pop();

            // Check character match and movement rules
            if (startChar != targetChar ||
                (startChar == 'L' && startIndex < targetIndex) ||
                (startChar == 'R' && startIndex > targetIndex))
                return false;
        }

        return true;
    }
};
```

#### Complexity Analysis

LetÂ nÂ be the size of theÂ `start`Â andÂ `target`Â strings.

- Time complexity:Â O(n)
    
    The algorithm iterates through both strings once, which takesÂ O(n)Â time. Pushing elements into the queues and popping elements from the queues also takeÂ O(n)Â time in total. Therefore, the overall time complexity isÂ O(n).
    
- Space complexity:Â O(n)
    
    The space complexity is determined by the space used by the two queues. In the worst case, if all characters in the strings are non-underscore, both queues will storeÂ nÂ elements each. Thus, the space complexity isÂ O(n).
    

---

### Approach 3: Two pointer

#### Intuition

Instead of using additional data structures like queues or generating possible states, we can directly compare both strings by scanning them simultaneously using two pointers. These pointers will help us compare the correspondingÂ `'L'`Â andÂ `'R'`Â pieces. When we encounter underscores, we can simply skip over them because they don't affect the validity of the transformation.

What really matters is the relative positions of theÂ `'L'`Â andÂ `'R'`Â pieces and whether they can move to their target positions according to the movement rules. Each time we find anÂ `'L'`Â orÂ `'R'`Â in both strings (after skipping underscores), we can immediately check if the movement is possible based on their positions:

- `'L'`Â pieces can only move left, so their position in theÂ `start`Â string must be greater than or equal to their position in theÂ `target`Â string.
- `'R'`Â pieces can only move right, so their position in theÂ `start`Â string must be less than or equal to their position in theÂ `target`Â string.

To implement this, we use two pointers,Â `startIndex`Â andÂ `targetIndex`, to traverse theÂ `start`Â andÂ `target`Â strings respectively. By making a single pass through the strings, we validate two key aspects:

1. Character Matching: Ensure that the sequence ofÂ `'L'`Â andÂ `'R'`Â pieces is identical in both strings.
2. Position Constraints: Check thatÂ `'L'`Â pieces don't need to move right andÂ `'R'`Â pieces don't need to move left.

By checking these conditions as we go, we can achieve the same validation as a more complex queue-based approach, but with constant space complexity and cleaner code.

> For a more comprehensive understanding of the two-pointer technique, check out theÂ [Two Pointer Explore Card ğŸ”—](https://leetcode.com/explore/learn/card/array-and-string/205/array-two-pointer-technique/). This resource provides an in-depth look at the two-pointer approach, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.

#### Algorithm

- InitializeÂ `startLength`Â as the length of theÂ `start`Â string.
    
- Initialize two pointers,Â `startIndex`Â andÂ `targetIndex`, both set toÂ `0`, to traverse theÂ `start`Â andÂ `target`Â strings.
    
- While eitherÂ `startIndex`Â orÂ `targetIndex`Â is less thanÂ `startLength`:
    
    - Skip underscores in theÂ `start`Â string by incrementingÂ `startIndex`Â until a non-underscore character is found or the end of the string is reached.
    - Skip underscores in theÂ `target`Â string by incrementingÂ `targetIndex`Â until a non-underscore character is found or the end of the string is reached.
    - If one string is fully traversed and the other is not, returnÂ `false`Â as both strings should be exhausted simultaneously.
    - If the characters atÂ `start[startIndex]`Â andÂ `target[targetIndex]`Â do not match, returnÂ `false`Â as the transformations are invalid.
    - If the character isÂ `'L'`Â inÂ `start`, ensureÂ `startIndex >= targetIndex`Â (left pieces can only move left); otherwise, returnÂ `false`.
    - If the character isÂ `'R'`Â inÂ `start`, ensureÂ `startIndex <= targetIndex`Â (right pieces can only move right); otherwise, returnÂ `false`.
- Increment bothÂ `startIndex`Â andÂ `targetIndex`Â to move to the next characters.
    
- If the loop ends without returningÂ `false`, all conditions for a valid transformation are satisfied; returnÂ `true`.
    

#### Implementation

```cpp
class Solution {
public:
    bool canChange(string start, string target) {
        int startLength = start.size();
        // Pointer for start string and target string
        int startIndex = 0, targetIndex = 0;

        while (startIndex < startLength || targetIndex < startLength) {
            // Skip underscores in start
            while (startIndex < startLength && start[startIndex] == '_') {
                startIndex++;
            }
            // Skip underscores in target
            while (targetIndex < startLength && target[targetIndex] == '_') {
                targetIndex++;
            }
            // If one string is exhausted, both should be exhausted
            if (startIndex == startLength || targetIndex == startLength) {
                return startIndex == startLength && targetIndex == startLength;
            }

            // Check if the pieces match and follow movement rules
            if (start[startIndex] != target[targetIndex] ||
                (start[startIndex] == 'L' && startIndex < targetIndex) ||
                (start[startIndex] == 'R' && startIndex > targetIndex))
                return false;

            startIndex++;
            targetIndex++;
        }

        // If all conditions are satisfied, return true
        return true;
    }
};
```

#### Complexity Analysis

LetÂ nÂ be the size of theÂ `start`Â andÂ `target`Â strings.

- Time complexity:Â O(n)
    
    The algorithm iterates through both strings once, skipping underscores and comparing characters. Each character is processed at most once, resulting in a linear time complexity.
    
    - The innerÂ `while`Â loops that skip underscores run in constant time for each character, so they do not increase the overall time complexity.
    - The mainÂ `while`Â loop runs until both indices reach the end of the strings, which takesÂ O(n)Â time in the worst case.
- Space complexity:Â O(1)
    
    The space complexity is constant because the algorithm uses a fixed amount of extra space regardless of the input size.
    
    - The only additional space used is for the indicesÂ `startIndex`Â andÂ `targetIndex`, which are single integer variables.
    - No additional data structures are used that grow with the input size.