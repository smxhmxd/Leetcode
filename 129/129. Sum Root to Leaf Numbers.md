### Description

You are given theÂ `root`Â of a binary tree containing digits fromÂ `0`Â toÂ `9`Â only.

Each root-to-leaf path in the tree represents a number.

- For example, the root-to-leaf pathÂ `1 -> 2 -> 3`Â represents the numberÂ `123`.

ReturnÂ _the total sum of all root-to-leaf numbers_. Test cases are generated so that the answer will fit in aÂ **32-bit**Â integer.

AÂ **leaf**Â node is a node with no children.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg)

**Input:** root = [1,2,3]
**Output:** 25
**Explanation:**
The root-to-leaf path `1->2` represents the number `12`.
The root-to-leaf path `1->3` represents the number `13`.
Therefore, sum = 12 + 13 = `25`.

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg)

**Input:** root = [4,9,0,5,1]
**Output:** 1026
**Explanation:**
The root-to-leaf path `4->9->5` represents the number 495.
The root-to-leaf path `4->9->1` represents the number 491.
The root-to-leaf path `4->0` represents the number 40.
Therefore, sum = 495 + 491 + 40 = `1026`.

**Constraints:**

- The number of nodes in the tree is in the rangeÂ `[1, 1000]`.
- `0 <= Node.val <= 9`
- The depth of the tree will not exceedÂ `10`.

**My Implementation**

```cpp
//Recursion-1
//T.C : O(n)
//S.C : O(1)
class Solution {
public:
    
    int find(TreeNode* root, int curr) {
        
        if(!root)
            return 0;
        
        curr = curr*10 + root->val;
        
        if(root->left == NULL && root->right == NULL) 
        {//Return current node if it is a leave node
            return curr;
        }
        
        int left_num  = find(root->left, curr);
        int right_num = find(root->right, curr);
        
        return left_num + right_num;
    }
    
    int sumNumbers(TreeNode* root) {
        return find(root, 0);
    }
};
```

# ğŸ¯ Problem Explanation:

The problem is about finding the sum of numbers represented by root-to-leaf paths in a binary tree. Each root-to-leaf path represents a number formed by concatenating the values of nodes along the path from the root to the leaf.

For example, given the binary tree:

```
        1
       / \
      2   3
```

The root-to-leaf paths areÂ `1->2`Â andÂ `1->3`, which represent the numbersÂ `12`Â andÂ `13`Â respectively. The sum of these numbers isÂ `12 + 13 = 25`.

# ğŸ§  Thinking Behind the Solution:

To solve this problem, we can use Depth-First Search (DFS) traversal of the binary tree. As we traverse from the root to each leaf node, we maintain aÂ `path_sum`Â variable which accumulates the number formed by the nodes visited so far.

# âœ…Approach:

To solve the problem of finding the sum of numbers represented by root-to-leaf paths in a binary tree using a Depth-First Search (DFS) approach, we can follow these steps:

1. **Use DFS Algorithm**:
    
    - Implement a DFS traversal of the binary tree, starting from the root.
    - Maintain a variable to keep track of the current number formed from the root to the current node as you traverse.
2. **DFS Recursive Function**:
    
    - Define a recursive function (`dfs`Â function) that takes the current node, the current path value, and a variable to accumulate the sum of all root-to-leaf path numbers.
    - If the current node isÂ `None`, return immediately (base case for leaf nodes).
    - Update the current path value by appending the current node's value (e.g.,Â `path_sum = path_sum * 10 + node.val`).
    - If the current node is a leaf node (i.e., it has no children), add theÂ `path_sum`Â to the sum.
    - Recursively call the function for the left and right children of the current node, passing the updatedÂ `path_sum`.
3. **Initialize and Call the DFS Function**:
    
    - Start the DFS traversal from the root node with an initialÂ `path`Â ofÂ `0`.
    - Accumulate the sum of all root-to-leaf path numbers using the DFS function.
4. **Return the Result**:
    
    - After the DFS traversal completes, return the accumulated sum, which represents the total sum of all root-to-leaf path numbers in the binary tree.

# Let's walkthroughğŸš¶ğŸ»â€â™‚ï¸ the implementation process with an example for better understandingğŸ¯:

Let's walkthrough the execution for a sample binary tree:

```
        1
       / \
      2   3
```

- **Initial Call**:Â `sumNumbers(root)`
    
    - `root`: Node with valueÂ `1`
    - `path_sum`:Â `0`
- **Execution**:
    
    1. `dfs(1, 0)`Â â†’Â `dfs(2, 1)`Â (left child)
    2. `dfs(2, 10)`Â â†’Â `dfs(None, 12)`Â (left child is None, returnÂ `12`)
    3. `dfs(1, 0)`Â â†’Â `dfs(3, 1)`Â (right child)
    4. `dfs(3, 10)`Â â†’Â `dfs(None, 13)`Â (left child is None, returnÂ `13`)
- **Final Result**:Â `12 + 13 = 25`
    

# CodeğŸ‘©ğŸ»â€ğŸ’»:

```cpp
class Solution {
public:
    int sumNumbers(TreeNode* root) {
        return dfs(root, 0);
    }
    
    int dfs(TreeNode* node, int pathSum) {
        if (!node)
            return 0;
        
        pathSum = pathSum * 10 + node->val;
        
        if (!node->left && !node->right)
            return pathSum;
        
        return dfs(node->left, pathSum) + dfs(node->right, pathSum);
    }
};
```