### Description

You are given aÂ **0-indexed**Â integer arrayÂ `nums`. A subarray ofÂ `nums`Â is calledÂ **continuous**Â if:

- LetÂ `i`,Â `i + 1`, ...,Â `j`Â be the indices in the subarray. Then, for each pair of indicesÂ `i <= i1, i2 <= j`,Â `0 <= |nums[i1] - nums[i2]| <= 2`.

ReturnÂ _the total number ofÂ **continuous**Â subarrays._

A subarray is a contiguousÂ **non-empty**Â sequence of elements within an array.

**Example 1:**

```cpp
Input: nums = [5,4,2,4]
Output: 8
```
**Explanation:** 
Continuous subarray of size 1: [5], [4], [2], [4].
Continuous subarray of size 2: [5,4], [4,2], [2,4].
Continuous subarray of size 3: [4,2,4].
Thereare no subarrys of size 4.
Total continuous subarrays = 4 + 3 + 1 = 8.
It can be shown that there are no more continuous subarrays.

**Example 2:**

```cpp
Input: nums = [1,2,3]
Output: 6
```
**Explanation:** 
Continuous subarray of size 1: [1], [2], [3].
Continuous subarray of size 2: [1,2], [2,3].
Continuous subarray of size 3: [1,2,3].
Total continuous subarrays = 3 + 2 + 1 = 6.

**Constraints:**

- `1 <= nums.length <= 10^5`
- `1 <= nums[i] <= 10^9`

**My Implementation**

```cpp
//Approach-1 (Using Ordered Map)
//T.C : ~O(n) - Explained in the video why O(n) ?
//S.C : ~O(1) - Explained in the video why O(1) ?
class Solution {
public:
    long long continuousSubarrays(vector<int>& nums) {
        int n = nums.size();

        map<int, int> mp;

        int i = 0;
        int j = 0;

        long long count = 0;

        while(j < n) {
            mp[nums[j]]++;
            
            while(abs(mp.rbegin()->first - mp.begin()->first) > 2) { //it means it is out of the bound
                //shrink window -move i index
                mp[nums[i]] -= 1;
                if(mp[nums[i]] == 0) {
                    mp.erase(nums[i]);
                }
                i++;
            }

            count += j-i+1;
            j++;
        }

        return count;
    }
};



//Approach-2 (Using Ordered Map)
//T.C : O(nlogn)
//S.C : O(n)
class Solution {
public:
    #define P pair<int, int>

    long long continuousSubarrays(vector<int>& nums) {
        int n = nums.size();

        priority_queue<P, vector<P>, greater<P>> minHeap;
        priority_queue<P> maxHeap;


        int i = 0;
        int j = 0;
        long long count = 0;

        while(j < n) { //O(n)
            minHeap.push({nums[j], j}); //Log(n)
            maxHeap.push({nums[j], j}); //Log(n)

            while(abs(maxHeap.top().first - minHeap.top().first) > 2) {
                i++;

                while(!maxHeap.empty() && maxHeap.top().second < i) {
                    maxHeap.pop();
                }

                while(!minHeap.empty() && minHeap.top().second < i) {
                    minHeap.pop();
                }
            }

            count += j-i+1;
            j++;
        }
        //T.C: O(nlogn)
        return count;
    }
};
```

## Solution

---

### Approach 1: Sorted Map

#### Intuition

The main challenge in this problem is to understand what makes a subarray 'continuous'. A subarray is considered continuous if the difference between any two elements within it is no more than 2. Understanding this simplifies the task and allows us to focus on the largest and smallest values, rather than checking every pair of elements.

Consider the subarray [4, 5, 3] from the array [4, 5, 3, 2, 6]. This subarray is valid because the difference between the largest element (5) and the smallest (3) is 2 or less. We don't need to evaluate any other pairs of elements in the array, since they can't possibly lead to a higher difference.

To solve this problem, we need a mechanism to evaluate all possible subarrays efficiently. A sliding window approach, with a variable-sized window, is well-suited for this purpose. We'll start with an empty window and expand it by adding elements from the array, as long as the difference between the maximum and minimum elements in the window is 2 or less. If this condition is violated, we shrink the window from the left until it becomes valid again.

Tracking the maximum and minimum values efficiently in each window is essential for performance. It is possible to repeatedly iterate over each window to find the values, but that method is too slow for larger arrays.

A more efficient method is to use a sorted map, which maintains elements in sorted order and allows quick retrieval of the maximum and minimum values in logarithmic time. The addition and removal of elements from a sorted map are similarly efficient, also taking logarithmic time.

As we expand the window, we add each new element to the sorted map. To check if the window remains valid, we compare the smallest and largest elements in the map. If their difference exceeds 2, we remove elements from the left until the condition is satisfied.

Finally, we need to count the valid subarrays. For a valid window that spans from pointerÂ `left`Â toÂ `right`, the number of valid subarrays ending atÂ `right`Â is calculated asÂ `right - left + 1`. This is because every subarray that starts at any pointer betweenÂ `left`Â andÂ `right`Â and ends atÂ `right`Â is considered valid. We sum up this count for all valid windows across the entire array and return the total as our final answer.


#### Algorithm

- Initialize a sorted mapÂ `freq`Â to maintain a sorted frequency map of elements in the current window.
- Initialize variables:
    - `left`Â andÂ `right`Â toÂ `0`Â to mark the boundaries of the sliding window.
    - `n`Â to store the length of the input array.
    - `count`Â to 0 to store the total count of valid subarrays.
- While theÂ `right`Â pointer is less than the length ofÂ `nums`:
    - Add the current element at indexÂ `right`Â to the frequency map. If the element exists, increment its count, else set the count toÂ `1`.
    - While the difference between the maximum and minimum elements in the window exceeds 2:
        - Decrement frequency of the element at indexÂ `left`Â in the map
        - If the frequency becomesÂ `0`, remove the element from the map.
        - Increment theÂ `left`Â pointer to shrink the window.
    - Add the count of all valid subarrays ending at the currentÂ `right`Â pointer (calculated asÂ `right - left + 1`).
    - Increment theÂ `right`Â pointer to expand the window.
- Return the final count of all valid subarrays.

#### Implementation

```cpp
class Solution {
public:
    long long continuousSubarrays(vector<int>& nums) {
        // Map to maintain sorted frequency map of current window
        map<int, int> freq;
        int left = 0, right = 0;
        int n = nums.size();
        long long count = 0;  // Total count of valid subarrays

        while (right < n) {
            // Add current element to frequency map
            freq[nums[right]]++;

            // While window violates the condition |nums[i] - nums[j]| â‰¤ 2
            // Shrink window from left
            while (freq.rbegin()->first - freq.begin()->first > 2) {
                // Remove leftmost element from frequency map
                freq[nums[left]]--;
                if (freq[nums[left]] == 0) {
                    freq.erase(nums[left]);
                }
                left++;
            }

            // Add count of all valid subarrays ending at right
            count += right - left + 1;
            right++;
        }

        return count;
    }
};
```

#### Complexity Analysis

LetÂ nÂ be the length of the input arrayÂ `nums`.

- Time complexity:Â O(nlogk)â‰ˆO(n)
    
    The outer loop iterates through the array once with theÂ `right`Â pointer, takingÂ O(n)Â operations. For each element, we perform map operations (insertion, deletion, finding min/max) which takeÂ O(logk)Â time, whereÂ kÂ is the size of the map. Since we maintain a window where theÂ maxâˆ’minâ‰¤2, the size of the sorted mapÂ kÂ is bounded byÂ 3Â (as elements can only differ byÂ 0,Â 1, orÂ 2). Therefore,Â logkÂ is effectively constant, making the overall time complexityÂ O(n).
    
    In the Python3 implementation, finding min/max keys in a dictionary takesÂ O(k)Â time whereÂ kÂ is the window size, making each iteration potentially slower than a sorted map'sÂ O(logk)Â operations. However, this has a negligible effect in this problem sinceÂ kÂ is bounded byÂ 3.
    
- Space complexity:Â O(k)â‰ˆO(1)
    
    The sorted map stores elements within the current window. Since the difference between any two elements in a valid window cannot exceedÂ 2, the maximum number of unique elements (k) possible in the map at any time isÂ 3. Therefore, the space complexity is constant,Â O(1).
    

---

### Approach 2: Priority Queue

#### Intuition

The main focus of our previous approach was to efficiently find the maximum and minimum values within a given window. Another data structure that excels at this task is a heap, or a priority queue.

Since a heap can only remove either the maximum or the minimum value, not both, we'll need two heaps: a max-heap and a min-heap. We'll store the indices of the elements in the arrayÂ `nums`, and the heaps will be organized based on the corresponding values in the array. The basic idea remains the same: we expand the window and add the new element to both heaps. This process continues as long as the difference between the maximum element (at the top of the max-heap) and the minimum element (at the top of the min-heap) is no greater than 2.

If the condition is violated, we need to move the start of the window forward until the condition is satisfied again. For each step we move theÂ `left`Â pointer, we must clean up our heaps to discard any elements that are before the start of the window (this is where storing the indices becomes useful).

Just like with our previous solution, once we have a valid window, counting the number of valid subarrays ending at the currentÂ `right`Â pointer is straightforward: it's simplyÂ `right - left + 1`. Each valid window contributes this many continuous subarrays to our final answer.

> For a more comprehensive understanding of heaps, check out theÂ [Heap Explore Card ðŸ”—](https://leetcode.com/explore/featured/card/heap/). This resource provides an in-depth look at the heap data structure, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.

#### Algorithm

Initialize variables:

- `left`Â andÂ `right`Â to 0 to mark the boundaries of the sliding window.
- `count`Â to 0 to store the total count of valid subarrays.
- Initialize:
    - a min-heapÂ `minHeap`Â that stores indices, sorted by their corresponding values inÂ `nums`Â in ascending order.
    - a max-heapÂ `maxHeap`Â that stores indices, sorted by their corresponding values in the input array in descending order.
- While theÂ `right`Â pointer is less than the array length:
    - Add the current indexÂ `right`Â to both the min-heap and the max-heap.
    - While theÂ `left`Â pointer is less than theÂ `right`Â pointer and the difference between the maximum and minimum elements in the window exceeds 2:
        - Increment theÂ `left`Â pointer to shrink the window.
        - Remove all indices from the max-heap and the min-heap that are less than theÂ `left`Â pointer (outdated indices).
    - Add the count of all valid subarrays ending at the currentÂ `right`Â pointer (calculated asÂ `right - left + 1`)
    - Increment theÂ `right`Â pointer to expand the window.
- Return the finalÂ `count`Â of all valid subarrays.

#### Implementation

```cpp
class Solution {
public:
    long long continuousSubarrays(vector<int>& nums) {
        int left = 0, right = 0;
        long long count = 0;  // Total count of valid subarrays

        // Min and max heaps storing indices, sorted by nums[index] values
        priority_queue<int, vector<int>, function<bool(int, int)>> minHeap(
            [&nums](int a, int b) { return nums[a] > nums[b]; });
        priority_queue<int, vector<int>, function<bool(int, int)>> maxHeap(
            [&nums](int a, int b) { return nums[a] < nums[b]; });

        while (right < nums.size()) {
            // Add current index to both heaps
            minHeap.push(right);
            maxHeap.push(right);

            // While window violates |nums[i] - nums[j]| â‰¤ 2 condition
            // Shrink window from left and remove outdated indices
            while (left < right &&
                   nums[maxHeap.top()] - nums[minHeap.top()] > 2) {
                left++;

                // Remove indices that are now outside window
                while (!maxHeap.empty() && maxHeap.top() < left) {
                    maxHeap.pop();
                }
                while (!minHeap.empty() && minHeap.top() < left) {
                    minHeap.pop();
                }
            }

            // Add count of all valid subarrays ending at right
            count += right - left + 1;
            right++;
        }

        return count;
    }
};
```

#### Complexity Analysis

LetÂ nÂ be the length of the input arrayÂ `nums`.

- Time complexity:Â O(nlogn)
    
    The outer loop iterates through the array once with theÂ `right`Â pointer, takingÂ O(n)Â operations. For each element, we perform heap operations (insertion and deletion) which takeÂ O(logn)Â time. Additionally, in the worst case, for eachÂ `right`Â pointer position, we might need to remove multiple outdated indices from both heaps, each removal takingÂ O(logn)Â time. Therefore, the overall time complexity isÂ O(nlogn).
    
- Space complexity:Â O(n)
    
    The min heap and max heap both store indices of the array elements. In the worst case (when all elements in the array differ by at mostÂ 2), both heaps might store all indices from the array simultaneously, making the space complexityÂ O(n).
    

---

### Approach 3: Monotonic Deque

#### Intuition

Each addition and deletion operation in a sorted map or a heap takesÂ O(logn)Â time. While this is quite efficient, we can still do better.

Consider Example 1 from the problem description, whereÂ `nums: [5, 4, 2, 4]`. When the window expands to includeÂ `2`Â at indexÂ `2`, it becomes the minimum value in the window. Notice that the previous minimum (`4`Â at indexÂ `1`) is no longer relevant for the minimum calculation since it can never be the minimum value in the window again. Similarly, if we're tracking maximums and we encounter a value larger than some previous values, those smaller values can never be the maximum in any window containing our new value. They become irrelevant for our maximum tracking purposes.

To find the minimum value in the window, we need a data structure that only keeps track of the minimum value encountered most recently and discards any larger values found previously. Also, if a new element comes that is larger than the current minimum, the data structure needs to hold on to it in case the current minimum goes out of the window scope and this new element becomes the new minimum. The data structure perfectly suited for these needs is a monotonic queue.

We'll be using a deque (doubly ended queue) in our implementation to make the removal of irrelevant indices easier. A doubly ended queue allows pushing and popping elements from both sides of the queue. We maintain two deques:

1. A min deque to track the minimum values in the current window. It will always store indices of elements in increasing order of their values.
2. A max deque to track the maximum values in the current window. It will store indices in decreasing order of their values.

As with our previous approaches, we'll start our window from the first element and introduce values one by one. For each element, we first need to check whether adding the element maintains the monotonicity of the queue. The max deque needs to be monotonically decreasing so that the biggest element is at the top, and vice versa for the min deque. For each deque, we'll pop elements from the back until the monotonicity is satisfied, and then add the current index.

Now, we need to check whether adding the new element breaks our condition or not. If it does, we need to move theÂ `left`Â pointer forward. We place theÂ `left`Â pointer past the smaller index among the tops of the queues, so we can jump directly past whichever of these appears first in our array. This lets us shrink our window optimally, removing the exact elements causing our property violation.

Finally, once the window is satisfied, we count the number of subarrays that can be formed by the current window. The total count over all the windows is our answer.

#### Algorithm

- Initialize a deque:
    - `maxQ`Â to maintain a monotonically decreasing sequence of indices for tracking the maximum elements.
    - `minQ`Â to maintain a monotonically increasing sequence of indices for tracking the minimum elements.
- Initialize variables:
    - `left`Â to 0 to mark the start of the sliding window.
    - `count`Â to 0 to store the total count of valid subarrays.
- For each positionÂ `right`Â in the array:
    - While theÂ `maxQ`Â is not empty and the element at the last index inÂ `maxQ`Â is less than the current element:
        - Remove the last element from theÂ `maxQ`.
    - Add the current index to theÂ `maxQ`.
    - While theÂ `minQ`Â is not empty and the element at the last index inÂ `minQ`Â is greater than the current element:
        - Remove the last element from theÂ `minQ`.
    - Add the current index to theÂ `minQ`.
    - While both queues are not empty and the difference between the maximum and minimum elements exceedsÂ `2`:
        - If the index at the front ofÂ `maxQ`Â is less than the index at the front ofÂ `minQ`:
            - Update theÂ `left`Â pointer to be one position after the front ofÂ `maxQ`.
            - Remove the front element fromÂ `maxQ`.
        - Else:
            - Update theÂ `left`Â pointer to be one position after the front ofÂ `minQ`.
            - Remove the front element fromÂ `minQ`.
    - Add the count of all valid subarrays ending at the current right pointer (calculated asÂ `right - left + 1`)
- Return the final count of all valid subarrays.

#### Implementation

```cpp
class Solution {
public:
    long long continuousSubarrays(vector<int>& nums) {
        // Monotonic deque to track maximum and minimum elements
        deque<int> maxQ, minQ;
        int left = 0;
        long long count = 0;

        for (int right = 0; right < nums.size(); right++) {
            // Maintain decreasing monotonic deque for maximum values
            while (!maxQ.empty() && nums[maxQ.back()] < nums[right]) {
                maxQ.pop_back();
            }
            maxQ.push_back(right);

            // Maintain increasing monotonic deque for minimum values
            while (!minQ.empty() && nums[minQ.back()] > nums[right]) {
                minQ.pop_back();
            }
            minQ.push_back(right);

            // Shrink window if max-min difference exceeds 2
            while (!maxQ.empty() && !minQ.empty() &&
                   nums[maxQ.front()] - nums[minQ.front()] > 2) {
                // Move left pointer past the element that breaks the condition
                if (maxQ.front() < minQ.front()) {
                    left = maxQ.front() + 1;
                    maxQ.pop_front();
                } else {
                    left = minQ.front() + 1;
                    minQ.pop_front();
                }
            }

            // Add count of all valid subarrays ending at current right pointer
            count += right - left + 1;
        }
        return count;
    }
};
```

#### Complexity Analysis

LetÂ nÂ be the length of the input arrayÂ `nums`.

- Time complexity:Â O(n)
    
    The outer loop iterates through the array once, takingÂ O(n)Â operations. For each element, we perform operations on the monotonic deques. Although we have nested while loops, each element can be added and removed from each deque exactly once throughout the entire process. The amortized cost of all deque operations over the entire execution isÂ O(n).
    
    Thus, the overall time complexity isÂ O(n).
    
- Space complexity:Â O(n)
    
    The monotonic deques store indices of the array elements. In the worst case (when all elements in the array are in decreasing order forÂ `maxQ`Â or increasing order forÂ `minQ`), both deques might store all indices from the array simultaneously, making the space complexityÂ O(n).
    
    However, in practice, due to the constraint that the max-min difference must beÂ â‰¤2, the deques will typically store far fewer elements.
    

---

### Approach 4: Optimized Two Pointer

#### Intuition

Instead of maintaining complex data structures to track our window's properties, in this approach, we will directly calculate the number of valid subarrays in each window using a mathematical formula.

Consider how a valid window evolves as we move through the array. Each time we add a new element, we have two possibilities: either it maintains the condition that theÂ maxâˆ’minâ‰¤2, or it breaks this condition. When the condition breaks, we know that all previous subarrays up to that point form a complete, valid window. This gives us our first key insight: we can count all the subarrays before that point and add them to our result. To count all subarrays in a window of lengthÂ n, we can use the formulaÂ nâ‹…(n+1)/2.

However, there's an important observation to make here: when the condition breaks, instead of starting completely fresh, we can expand backward from our current position to include some previous elements. Consider the arrayÂ `[1, 4, 3, 5]`. Let's say we encounter the valueÂ `5`Â after seeing valuesÂ `3`Â andÂ `4`. WhileÂ `5`Â might break our current window, we can still include bothÂ `3`Â andÂ `4`Â in our new window since they are within 2 ofÂ `5`.

This leads to our second key insight: after a window breaks, we can greedily expand leftward as long as elements remain within 2 of our current value. This backward expansion is crucial because it captures valid subarrays that we would miss if we simply started fresh at each breakpoint.

However, this backward expansion introduces a counting challenge. When we expand backward, we've already counted some subarrays in our previous window that we'll count again in our new window. The solution is simple: we subtract the overcounted subarrays using the sameÂ nâ‹…(n+1)/2Â formula for the overlapping portion.

Let's take the example arrayÂ `[1, 4, 3, 5]`Â to clarify this. Initially, we build a windowÂ `[1, 4]`, which breaks when we reachÂ `3`. At this point, we count all subarrays inÂ `[1, 4]`. Then, starting atÂ `3`, we can actually expand backward to includeÂ `4`Â (but notÂ `1`), forming a new windowÂ `[4, 3]`. We subtract the overcounted subarrays for the portion containing justÂ `[4]`, then continue our process.

We continue this process until theÂ `right`Â end of the window reaches the end of the array and we exit the loop. However, remember that the final subarray hasn't broken yet, so it hasn't been added to our total count. We use theÂ nâ‹…(n+1)/2Â formula one last time to account for this subarray and return the total count as our answer.

#### Algorithm

- Initialize:
    - `left`Â andÂ `right`Â toÂ `0`Â to mark the boundaries of the sliding window.
    - `curMin`Â andÂ `curMax`Â to track the minimum and maximum elements in the current window.
    - `windowLen`Â toÂ `0`Â to store the length of the current valid window.
    - `total`Â toÂ `0`Â to store the total count of valid subarrays.
- Set the initial window minimum and maximum to the first element of the array.
- For each positionÂ `right`Â in the array:
    - Update the current window minimum and maximum with the current element.
    - If the difference between maximum and minimum exceedsÂ `2`:
        - Calculate the length of the previous valid window.
        - Add all possible subarrays from the previous valid window using the formulaÂ (nâ‹…(n+1))/2.
        - Start a new window at the current position.
        - Reset the minimum and maximum to the current element.
        - While theÂ `left`Â pointer can be expanded (not atÂ `0`Â and differenceÂ â‰¤Â 2):
            - Decrement the left pointer.
            - Update the window minimum and maximum with the newÂ `left`Â element.
        - If theÂ `left`Â pointer was expanded:
            - Calculate the new window length.
            - Subtract the overcounted subarrays using the same formulaÂ (nâ‹…(n+1))/2.
- Calculate the length of the final window.
- Add all possible subarrays from the final window using the formulaÂ (nâ‹…(n+1))/2.
- Return theÂ `total`Â count of valid subarrays.

#### Implementation

```cpp
class Solution {
public:
    long long continuousSubarrays(vector<int>& nums) {
        int right = 0, left = 0;
        int curMin, curMax;
        long long windowLen = 0, total = 0;

        // Initialize window with the first element
        curMin = curMax = nums[right];

        for (right = 0; right < nums.size(); right++) {
            // Update min and max for the current window
            curMin = min(curMin, nums[right]);
            curMax = max(curMax, nums[right]);

            // If window condition breaks (diff > 2)
            if (curMax - curMin > 2) {
                // Add subarrays from the previous valid window
                windowLen = right - left;
                total += (windowLen * (windowLen + 1) / 2);

                // Start a new window at the current position
                left = right;
                curMin = curMax = nums[right];

                // Expand left boundary while maintaining the condition
                while (left > 0 && abs(nums[right] - nums[left - 1]) <= 2) {
                    left--;
                    curMin = min(curMin, nums[left]);
                    curMax = max(curMax, nums[left]);
                }

                // Remove overcounted subarrays if left boundary expanded
                if (left < right) {
                    windowLen = right - left;
                    total -= (windowLen * (windowLen + 1) / 2);
                }
            }
        }

        // Add subarrays from the final window
        windowLen = right - left;
        total += (windowLen * (windowLen + 1) / 2);

        return total;
    }
};
```

#### Complexity Analysis

LetÂ nÂ be the length of the input arrayÂ `nums`.

- Time complexity:Â O(n)
    
    The algorithm iterates through the array once with theÂ `right`Â pointer, takingÂ O(n)Â operations. For each element, when the window condition breaks, we may need to expand theÂ `left`Â pointer backward. Although this involves a while loop, across the entire execution, theÂ `left`Â pointer can only visit each position at most twice. Therefore, the amortized time complexity remainsÂ O(n).
    
- Space complexity:Â O(1)
    
    The algorithm only uses a constant number of variables regardless of the input size. No additional data structures are used that grow with the input size. Thus, the space complexity is constant,Â O(1).

