### Description

Given a stringÂ `s`, partitionÂ `s`Â such that everyÂ 

substring

Â of the partition is aÂ 

**palindrome**

. ReturnÂ _all possible palindrome partitioning of_Â `s`.

**Example 1:**

**Input:** s = "aab"
**Output:** \[\["a","a","b"],\["aa","b"]]

**Example 2:**

**Input:** s = "a"
**Output:** \[\["a"]]

**Constraints:**

- `1 <= s.length <= 16`
- `s`Â contains only lowercase English letters.

**My Implementation**

```cpp
//Whenever a question asks for "Generating all possible" something, think about Backtracking once
//T.C : O(n * 2^n) - For a string of length n, there are 2^(ğ‘› âˆ’ 1) potential ways to partition it (since each position can either be a cut or not). and we also check palindrome O(n)
//S.C : O(n * 2^n) - Number of partitions * their length
class Solution {
public:
    int n;
    
    bool isPalindrome(string &s, int l, int r) {
        
        while(l < r) {
            if(s[l] != s[r])
                return false;
            l++;
            r--;
        }
        
        return true;
        
    }
    
    void backtrack(string &s, int idx, vector<string> curr, vector<vector<string>> &result) {
        
        if(idx == n) {
            result.push_back(curr);
            return;
        }
        
        
        for(int i = idx; i<n; i++) {
            
            if(isPalindrome(s, idx, i)) {
                
                curr.push_back(s.substr(idx, i-idx+1));
                
                backtrack(s, i+1, curr, result);
                
                curr.pop_back();
                
            }
            
        }
        
    }
    
    vector<vector<string>> partition(string s) {
        n = s.length();
        vector<vector<string>> result;
        vector<string> curr;
        
        backtrack(s, 0, curr, result);
        
        return result;
        
    }
};
```

# ğŸ¯Problem Explaination:

Given a stringÂ `s`, partitionÂ `s`Â such that every substring of the partition is a palindrome. Return all possible palindrome partitioning ofÂ `s`.

A palindrome is a string that reads the same backward as forward.

### ğŸ“¥Input:

A stringÂ `s`Â consisting of lowercase English letters.

### ğŸ“¤Output:

A list of lists containing all possible palindrome partitioning ofÂ `s`. Each inner list represents a partitioning where the substrings in it are palindromes.

# ğŸ” Methods To Solve This Problem:

I'll be covering two different methods to solve this problem:

1. Backtracking
2. Dynamic Programming

# 1ï¸âƒ£ Backtracking:

## ğŸ§ Thinking Behind the Solution:

The backtracking approach explores all possible ways to partition the string and checks if each partitioned substring is a palindrome. The key idea is to use a recursive function to try every possible partition and backtrack to explore other possibilities when a valid partition is found. This method ensures that all possible partitions are considered, but it may be less efficient due to redundant checks.

## âœ…Approach:

1. **Palindrome Check**: Create a helper functionÂ `is_palindrome`Â to check if a given substring is a palindrome.
2. **Recursive Backtracking**:
    - Define a recursive functionÂ `backtrack(start, path)`:
        - IfÂ `start`Â reaches the end of the stringÂ `s`, append the currentÂ `path`Â to the result list.
        - Iterate over all possible end positions fromÂ `start + 1`Â to the length of the string.
        - For each end position, check if the substringÂ `s[start:end]`Â is a palindrome.
        - If it is, recursively callÂ `backtrack`Â with the updated start position (`end`) and the current path plus the new palindrome substring.
3. **Initialization**: Initialize an empty listÂ `result`Â to store all valid partitions. Start the backtracking process from the beginning of the string with an empty path.
4. **Return Result**: Return theÂ `result`Â list containing all possible palindrome partitions.

# CodeğŸ‘¨ğŸ»â€ğŸ’»:

```cpp
class Solution {
public:
    vector<vector<string>> partition(string s) {
        vector<vector<string>> result;
        vector<string> path;
        backtrack(s, 0, path, result);
        return result;
    }

private:
    void backtrack(const string& s, int start, vector<string>& path, vector<vector<string>>& result) {
        // If we've reached the end of the string, add the current partition to the result list
        if (start == s.length()) {
            result.push_back(path);
            return;
        }
        // Explore all possible partitions
        for (int end = start + 1; end <= s.length(); ++end) {
            // If the current substring is a palindrome, add it to the current path
            if (isPalindrome(s, start, end - 1)) {
                path.push_back(s.substr(start, end - start));
                // Recur to find other partitions
                backtrack(s, end, path, result);
                // Backtrack to explore other partitions
                path.pop_back();
            }
        }
    }

    bool isPalindrome(const string& s, int left, int right) {
        // Check if the substring s[left:right+1] is a palindrome
        while (left < right) {
            if (s[left++] != s[right--]) {
                return false;
            }
        }
        return true;
    }
};
```

# Let's walkthroughğŸš¶ğŸ»â€â™‚ï¸ the implementation process with an example for better understandingğŸ¯:

### ğŸš¶ğŸ»â€â™€ï¸Walkthrough withÂ `s = "aab"`

1. **Initialization:**
    
    - `result = []`
    - `path = []`
    - `start = 0`
2. **First Call toÂ `backtrack`:**Â `backtrack("aab", 0, [], result)`
    
    - `start = 0`
    - Loop throughÂ `end`Â fromÂ `1`Â toÂ `3`.
3. **First Iteration (end = 1):**
    
    - `substring = "a"`Â (from indexÂ `0`Â toÂ `0`).
    - Check ifÂ `"a"`Â is a palindrome:Â `isPalindrome("aab", 0, 0)`Â returnsÂ `true`.
    - AddÂ `"a"`Â toÂ `path`:Â `path = ["a"]`.
    - Recursive call:Â `backtrack("aab", 1, ["a"], result)`
4. **Second Call toÂ `backtrack`:**Â `backtrack("aab", 1, ["a"], result)`
    
    - `start = 1`
    - Loop throughÂ `end`Â fromÂ `2`Â toÂ `3`.
5. **First Iteration (end = 2):**
    
    - `substring = "a"`Â (from indexÂ `1`Â toÂ `1`).
    - Check ifÂ `"a"`Â is a palindrome:Â `isPalindrome("aab", 1, 1)`Â returnsÂ `true`.
    - AddÂ `"a"`Â toÂ `path`:Â `path = ["a", "a"]`.
    - Recursive call:Â `backtrack("aab", 2, ["a", "a"], result)`
6. **Third Call toÂ `backtrack`:**Â `backtrack("aab", 2, ["a", "a"], result)`
    
    - `start = 2`
    - Loop throughÂ `end`Â fromÂ `3`Â toÂ `3`.
7. **First Iteration (end = 3):**
    
    - `substring = "b"`Â (from indexÂ `2`Â toÂ `2`).
    - Check ifÂ `"b"`Â is a palindrome:Â `isPalindrome("aab", 2, 2)`Â returnsÂ `true`.
    - AddÂ `"b"`Â toÂ `path`:Â `path = ["a", "a", "b"]`.
    - Recursive call:Â `backtrack("aab", 3, ["a", "a", "b"], result)`
8. **Fourth Call toÂ `backtrack`:**Â `backtrack("aab", 3, ["a", "a", "b"], result)`
    
    - `start = 3`, which equalsÂ `s.length()`.
    - AddÂ `path`Â toÂ `result`:Â `result = [["a", "a", "b"]]`.
    - Return from the function.
9. **Backtrack:**
    
    - RemoveÂ `"b"`Â fromÂ `path`:Â `path = ["a", "a"]`.
    - Return to the previous call:Â `backtrack("aab", 2, ["a", "a"], result)`.
10. **Backtrack:**
    
    - RemoveÂ `"a"`Â fromÂ `path`:Â `path = ["a"]`.
    - Return to the previous call:Â `backtrack("aab", 1, ["a"], result)`.
11. **Second Iteration (end = 3):**
    
    - `substring = "ab"`Â (from indexÂ `1`Â toÂ `2`).
    - Check ifÂ `"ab"`Â is a palindrome:Â `isPalindrome("aab", 1, 2)`Â returnsÂ `false`.
    - Continue loop.
12. **Backtrack:**
    
    - RemoveÂ `"a"`Â fromÂ `path`:Â `path = []`.
    - Return to the previous call:Â `backtrack("aab", 0, [], result)`.
13. **Second Iteration (end = 2):**
    
    - `substring = "aa"`Â (from indexÂ `0`Â toÂ `1`).
    - Check ifÂ `"aa"`Â is a palindrome:Â `isPalindrome("aab", 0, 1)`Â returnsÂ `true`.
    - AddÂ `"aa"`Â toÂ `path`:Â `path = ["aa"]`.
    - Recursive call:Â `backtrack("aab", 2, ["aa"], result)`
14. **Fifth Call toÂ `backtrack`:**Â `backtrack("aab", 2, ["aa"], result)`
    
    - `start = 2`
    - Loop throughÂ `end`Â fromÂ `3`Â toÂ `3`.
15. **First Iteration (end = 3):**
    
    - `substring = "b"`Â (from indexÂ `2`Â toÂ `2`).
    - Check ifÂ `"b"`Â is a palindrome:Â `isPalindrome("aab", 2, 2)`Â returnsÂ `true`.
    - AddÂ `"b"`Â toÂ `path`:Â `path = ["aa", "b"]`.
    - Recursive call:Â `backtrack("aab", 3, ["aa", "b"], result)`
16. **Sixth Call toÂ `backtrack`:**Â `backtrack("aab", 3, ["aa", "b"], result)`
    
    - `start = 3`, which equalsÂ `s.length()`.
    - AddÂ `path`Â toÂ `result`:Â `result = [["a", "a", "b"], ["aa", "b"]]`.
    - Return from the function.
17. **Backtrack:**
    
    - RemoveÂ `"b"`Â fromÂ `path`:Â `path = ["aa"]`.
    - Return to the previous call:Â `backtrack("aab", 2, ["aa"], result)`.
18. **Backtrack:**
    
    - RemoveÂ `"aa"`Â fromÂ `path`:Â `path = []`.
    - Return to the previous call:Â `backtrack("aab", 0, [], result)`.
19. **Third Iteration (end = 3):**
    
    - `substring = "aab"`Â (from indexÂ `0`Â toÂ `2`).
    - Check ifÂ `"aab"`Â is a palindrome:Â `isPalindrome("aab", 0, 2)`Â returnsÂ `false`.
    - Continue loop.
20. **End of Function:**
    
    - All iterations complete.
    - ReturnÂ `result = [["a", "a", "b"], ["aa", "b"]]`.

### ğŸ“¤Final Output

The final result is:

```java
[["a", "a", "b"], ["aa", "b"]]
```

# 2ï¸âƒ£ Dynamic Programming:

## ğŸ§ Thinking Behind the Solution:

The dynamic programming approach aims to optimize the palindrome checking process by precomputing whether substrings are palindromes. This avoids redundant palindrome checks during the partitioning process. The method leverages a DP table to store the palindrome status of substrings, which significantly reduces the overall time complexity.

### âœ…Approach:

1. **DP Table Initialization**: Create a 2D listÂ `dp`Â whereÂ `dp[i][j]`Â indicates whether the substringÂ `s[i:j+1]`Â is a palindrome.
2. **Populate DP Table**:
    - All single characters are palindromes, so setÂ `dp[i][i]`Â toÂ `True`Â for allÂ `i`.
    - For substrings of length 2, setÂ `dp[i][i+1]`Â toÂ `True`Â ifÂ `s[i]`Â is equal toÂ `s[i+1]`.
    - For longer substrings, use the relation: ifÂ `s[i]`Â is equal toÂ `s[j]`Â andÂ `dp[i+1][j-1]`Â isÂ `True`, thenÂ `dp[i][j]`Â isÂ `True`.
3. **Recursive Backtracking**:
    - Define a recursive functionÂ `backtrack(start, path)`:
        - IfÂ `start`Â reaches the end of the stringÂ `s`, append the currentÂ `path`Â to the result list.
        - Iterate over all possible end positions fromÂ `start`Â to the length of the string.
        - For each end position, use the precomputed DP table to check if the substringÂ `s[start:end+1]`Â is a palindrome.
        - If it is, recursively callÂ `backtrack`Â with the updated start position (`end + 1`) and the current path plus the new palindrome substring.
4. **Initialization**: Initialize an empty listÂ `result`Â to store all valid partitions. Start the backtracking process from the beginning of the string with an empty path.
5. **Return Result**: Return theÂ `result`Â list containing all possible palindrome partitions.

# CodeğŸ‘©ğŸ»â€ğŸ’»:

```cpp
class Solution {
public:
    vector<vector<string>> partition(string s) {
        int n = s.length();
        vector<vector<bool>> dp(n, vector<bool>(n, false));

        // Initialize the DP table for single characters and pairs
        for (int i = 0; i < n; ++i) {
            dp[i][i] = true;
        }
        for (int length = 2; length <= n; ++length) {
            for (int i = 0; i <= n - length; ++i) {
                int j = i + length - 1;
                if (s[i] == s[j] && (length == 2 || dp[i + 1][j - 1])) {
                    dp[i][j] = true;
                }
            }
        }

        vector<vector<string>> result;
        vector<string> path;
        backtrack(s, 0, path, result, dp);
        return result;
    }

private:
    void backtrack(const string& s, int start, vector<string>& path, vector<vector<string>>& result, const vector<vector<bool>>& dp) {
        // If we've reached the end of the string, add the current partition to the result list
        if (start == s.length()) {
            result.push_back(path);
            return;
        }
        // Explore all possible partitions
        for (int end = start; end < s.length(); ++end) {
            // Use the DP table to check if the substring s[start:end+1] is a palindrome
            if (dp[start][end]) {
                path.push_back(s.substr(start, end - start + 1));
                // Recur to find other partitions
                backtrack(s, end + 1, path, result, dp);
                // Backtrack to explore other partitions
                path.pop_back();
            }
        }
    }
};
```

# Let's walkthroughğŸš¶ğŸ»â€â™‚ï¸ the implementation process with an example for better understandingğŸ¯:

### ğŸš¶ğŸ»â€â™€ï¸Walkthrough withÂ `s = "aab"`

1. **Initialization:**
    
    - `s = "aab"`
    - `n = 3`Â (length ofÂ `s`)
    - `dp = [[false, false, false], [false, false, false], [false, false, false]]`
2. **Fill DP Table for Single Characters:**
    
    - `dp[0][0] = true`Â (since "a" is a palindrome)
    - `dp[1][1] = true`Â (since "a" is a palindrome)
    - `dp[2][2] = true`Â (since "b" is a palindrome)
    - `dp = [[true, false, false], [false, true, false], [false, false, true]]`
3. **Fill DP Table for Length 2:**
    
    - `i = 0, j = 1`
        - `s[0] == s[1]`Â ("a" == "a"), soÂ `dp[0][1] = true`
    - `i = 1, j = 2`
        - `s[1] != s[2]`Â ("a" != "b"), soÂ `dp[1][2] = false`
    - `dp = [[true, true, false], [false, true, false], [false, false, true]]`
4. **Fill DP Table for Length 3:**
    
    - `i = 0, j = 2`
        - `s[0] != s[2]`Â ("a" != "b"), soÂ `dp[0][2] = false`
    - `dp = [[true, true, false], [false, true, false], [false, false, true]]`
5. **Result and Path Initialization:**
    
    - `result = []`
    - `path = []`
6. **First Call toÂ `backtrack`:**Â `backtrack("aab", 0, [], result, dp)`
    
    - `start = 0`
    - Loop throughÂ `end`Â fromÂ `0`Â toÂ `2`.
7. **First Iteration (end = 0):**
    
    - `substring = "a"`Â (from indexÂ `0`Â toÂ `0`).
    - `dp[0][0]`Â isÂ `true`.
    - AddÂ `"a"`Â toÂ `path`:Â `path = ["a"]`.
    - Recursive call:Â `backtrack("aab", 1, ["a"], result, dp)`
8. **Second Call toÂ `backtrack`:**Â `backtrack("aab", 1, ["a"], result, dp)`
    
    - `start = 1`
    - Loop throughÂ `end`Â fromÂ `1`Â toÂ `2`.
9. **First Iteration (end = 1):**
    
    - `substring = "a"`Â (from indexÂ `1`Â toÂ `1`).
    - `dp[1][1]`Â isÂ `true`.
    - AddÂ `"a"`Â toÂ `path`:Â `path = ["a", "a"]`.
    - Recursive call:Â `backtrack("aab", 2, ["a", "a"], result, dp)`
10. **Third Call toÂ `backtrack`:**Â `backtrack("aab", 2, ["a", "a"], result, dp)`
    
    - `start = 2`
    - Loop throughÂ `end`Â fromÂ `2`Â toÂ `2`.
11. **First Iteration (end = 2):**
    
    - `substring = "b"`Â (from indexÂ `2`Â toÂ `2`).
    - `dp[2][2]`Â isÂ `true`.
    - AddÂ `"b"`Â toÂ `path`:Â `path = ["a", "a", "b"]`.
    - Recursive call:Â `backtrack("aab", 3, ["a", "a", "b"], result, dp)`
12. **Fourth Call toÂ `backtrack`:**Â `backtrack("aab", 3, ["a", "a", "b"], result, dp)`
    
    - `start = 3`, which equalsÂ `s.length()`.
    - AddÂ `path`Â toÂ `result`:Â `result = [["a", "a", "b"]]`.
    - Return from the function.
13. **Backtrack:**
    
    - RemoveÂ `"b"`Â fromÂ `path`:Â `path = ["a", "a"]`.
    - Return to the previous call:Â `backtrack("aab", 2, ["a", "a"], result, dp)`.
14. **Backtrack:**
    
    - RemoveÂ `"a"`Â fromÂ `path`:Â `path = ["a"]`.
    - Return to the previous call:Â `backtrack("aab", 1, ["a"], result, dp)`.
15. **Second Iteration (end = 2):**
    
    - `substring = "ab"`Â (from indexÂ `1`Â toÂ `2`).
    - `dp[1][2]`Â isÂ `false`.
    - Continue loop.
16. **Backtrack:**
    
    - RemoveÂ `"a"`Â fromÂ `path`:Â `path = []`.
    - Return to the previous call:Â `backtrack("aab", 0, [], result, dp)`.
17. **Second Iteration (end = 1):**
    
    - `substring = "aa"`Â (from indexÂ `0`Â toÂ `1`).
    - `dp[0][1]`Â isÂ `true`.
    - AddÂ `"aa"`Â toÂ `path`:Â `path = ["aa"]`.
    - Recursive call:Â `backtrack("aab", 2, ["aa"], result, dp)`
18. **Fifth Call toÂ `backtrack`:**Â `backtrack("aab", 2, ["aa"], result, dp)`
    
    - `start = 2`
    - Loop throughÂ `end`Â fromÂ `2`Â toÂ `2`.
19. **First Iteration (end = 2):**
    
    - `substring = "b"`Â (from indexÂ `2`Â toÂ `2`).
    - `dp[2][2]`Â isÂ `true`.
    - AddÂ `"b"`Â toÂ `path`:Â `path = ["aa", "b"]`.
    - Recursive call:Â `backtrack("aab", 3, ["aa", "b"], result, dp)`
20. **Sixth Call toÂ `backtrack`:**Â `backtrack("aab", 3, ["aa", "b"], result, dp)`
    
    - `start = 3`, which equalsÂ `s.length()`.
    - AddÂ `path`Â toÂ `result`:Â `result = [["a", "a", "b"], ["aa", "b"]]`.
    - Return from the function.
21. **Backtrack:**
    
    - RemoveÂ `"b"`Â fromÂ `path`:Â `path = ["aa"]`.
    - Return to the previous call:Â `backtrack("aab", 2, ["aa"], result, dp)`.
22. **Backtrack:**
    
    - RemoveÂ `"aa"`Â fromÂ `path`:Â `path = []`.
    - Return to the previous call:Â `backtrack("aab", 0, [], result, dp)`.
23. **Third Iteration (end = 2):**
    
    - `substring = "aab"`Â (from indexÂ `0`Â toÂ `2`).
    - `dp[0][2]`Â isÂ `false`.
    - Continue loop.
24. **End of Function:**
    
    - All iterations complete.
    - ReturnÂ `result = [["a", "a", "b"], ["aa", "b"]]`.

### ğŸ“¤Final Output

The final result is:

```java
[["a", "a", "b"], ["aa", "b"]]
```

